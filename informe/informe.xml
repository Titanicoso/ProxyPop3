<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc>
  <front>
    <title>
      Informe TPE Protocolos de comunicación
    </title>
    <author initials="F.D." surname="Delgado" fullname="Francisco Delgado">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <author initials="R.M.N.L" surname="Navarro Lajous" fullname="Rodrigo Manuel Navarro Lajous">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <author initials="S.F" surname="Favarón" fullname="Sebastián Favaron">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <author initials="A.C." surname="Calatayud" fullname="Agustín Calatayud">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <date month="11" year="2018"/>
    <area>Protocolos de Comunicación</area>
    <workgroup>Grupo 7</workgroup>
    <abstract>
      <t>Este documento informa sobre el trabajo realizado para el trabajo practico especial de la
        materia Protocolos de Comunicación por parte del grupo 7 del segundo cuatrimestre de 2018.
        Se encontrara una descripcion completa del trabajo realizado junto con el analisis del mismo
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Aplicaciones y protocolos desarrollados">
      <section title="Protocolo SPCP">
        <section title="introducción al protocolo">
          <t>El Simple Proxy Communication Protocol(SPCP) es un protocolo binario utilizado para poder
            configurar y obtener métricas de un servidor proxy. En el diseño del protocolo se priorizo
            la simpleza asi permitiendo que sea implementado lo mas fácilmente posible siempre y cuando
            no comprometa el objetivo principal de administrar el proxy
          </t>
        </section>
        <section title="Operación Básica">
          <t>Inicialmente, el servidor spcp inicializa su servicio escuchando en el puerto 9090 por default
            para aceptar conexiones sctp entrantes. Cuando el cliente desea utilizar el servicio este debe
            establecer una conexión sctp con el servidor.
          </t>
          <t>Una vez establecida la conexión se procede a la etapa de autenticación, el cliente manda su
            usuario y su contraseña y estos son validados por el servidor. Una vez autenticado se procede al
            estado de transacción en donde se mandan requests tanto para modificar el estado del proxy como
            para obtener métricas del mismo recibiendo para cada uno una respuesta con la informacion en el
            caso de que se haya podido obtener, o un estado de error apropiado. Finalmente se envía un request
            de terminación en donde se le indica al servidor que el cliente desea finalizar su sesión y el
            servidor da por finalizada la sesión.
          </t>
        </section>
        <section title="El request">
          <figure>
            <preamble>La estructura de un request</preamble>
            <artwork>
  +-----+-------+----------+----------+...+----------+----------+
  | CMD | NARGS | ARGLEN 1 |  ARG 1   |   | ARGLEN N |   ARG N  |
  +-----+-------+----------+----------+...+----------+----------+
  |  1  |   1   |    1     | Variable |   |    1     | Variable |
  +-----+-------+----------+----------+...+----------+----------+
            </artwork>
          </figure>
          <t>El request se compone por un numero variable de segmentos, estos son:
            <list>
              <t>CMD: El identificador de comando, tiene un tamaño de un byte.
              </t>
              <t>NARGS: La cantidad de argumentos, tiene tamaño de un byte.
              </t>
              <t>ARGLEN: Cada argumento se encuentra precedido por el largo del mismo, este tiene un maximo
                 de 255 ya que este campo tiene un byte de longitud.
              </t>
              <t>ARG: El argumento de tamaño anteriormente especificado, los argumentos son representaciones
                ASCII.
              </t>
            </list>
          </t>
        </section>
        <section title="La Response">
          <figure>
            <preamble>La estructura de un response</preamble>
            <artwork>
  +-------------+---------+----------+
  | STATUS_CODE | DATALEN |   DATA   |
  +-------------+---------+----------+
  |      1      |    1    | Variable |
  +-------------+---------+----------+
            </artwork>
          </figure>
          <t>El response se compone por un numero variable de segmentos, estos son:
            <list>
              <t>STATUS_CODE: Identifica el codigo de la respuesta.
              </t>
              <t>DATALEN: La longitud de los datos de la respuesta del servidor.
              </t>
              <t>DATA: Los datos enviados por el servidor, estos se encuentran en codificación ASCII.
              </t>
            </list>
          </t>
          <section title="Codigos de respuesta">
            <t>Discutimos brevemente los posibles codigos de respuesta que un servidor puede enviar a un cliente
            </t>
            <t>
              <list>
                <t>0x00: es el response de OK, indica que el request se ejecuto con exito por parte del servidor.
                </t>
                <t>0x01: Error de autenticación, indica que hubo un error al tratar de autenticar el usuario.
                </t>
                <t>0x02: Comando invalido, el comando que se envio en el request no es un comando valido.
                </t>
                <t>0x03: Argumentos invalidoos, indica que los argumentos para el comando no son validos.
                </t>
                <t>0x04: Error general, es el error de fallback del servidor cuando no puede especificar
                  por que fallo.
                </t>
              </list>
            </t>
          </section>
        </section>
        <section title="Estado de autenticación">
          <t>Una vez inicializada la conexión el servidor se encuentra en el estado de autenticación. El cliente
          debe proveer su usuario mediante el comando 0x00, al cual llamaremos USER.
          </t>
          <t>El comando USER se compone de la siguiente manera:
            <list>
              <t>Argumentos: uno, la representación ASCII del nombre de usuario.
              </t>
              <t>Restricciones: Solo se puede utilizar en el estado de autenticación una vez inicializada la conexión
                 o inmediatamente despues de un USER o PASS erróneo.
              </t>
              <t>Discusión: Primero se debe mandar el comando USER, si el usuario esta registrado entonces el servidor
                responde con una respuesta positiva mandando el byte 0x00. En caso contrario respondera con un 0x01
                (AUTH ERROR)
              </t>
            </list>
          </t>
          <t>Inmediatamente despues del comando USER debe proveer mediante otro request la contraseña asociada al
            usuario. Para esto emite un request al servidor con el comando 0x01, al cual le llamaremos PASS de
            ahora en adelante.
          </t>
          <t>El comando PASS se compone de la siguiente manera:
            <list>
              <t>Argumentos: uno, la representación ASCII de la contraseña.
              </t>
              <t>Restricciones: Solo se puede utilizar en el estado de autenticación una vez inicializada la conexión
                e inmediatamente después de un USER.
              </t>
            </list>
          </t>
        </section>
        <section title="Estado de transacción">
          <t>Ya habiendo sido autenticado el servidor procede al estado de transacción, en este estado se podra
             consular el estado del proxy como también alterarlo. Para esto se usan distintos comandos que
             procederemos a describir:
          </t>
          <t>0x02, conexiones concurrentes:
            <list>
              <t>Argumentos: ninguno
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: El comando obtiene la representación ASCII de la cantidad de conexiones al servidor
                que se encuentran establecidas al momento de procesarse el request. En el cazo de que el servidor
                no pueda responder satisfactoriamente al request este responderá con un estado de error apropiado.
              </t>
            </list>
          </t>
          <t>0x03, bytes transferidos:
            <list>
              <t>Argumentos: ninguno.
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: El comando obtiene como respuesta positiva la representación ASCII de la cantidad de
                 bytes que fueron transferidos desde que el servidor arranco. En el cazo de que el servidor no pueda
                responder satisfactoriamente al request este responderá con un estado de error apropiado.
              </t>
            </list>
          </t>
          <t>0x04, Accesos históricos:
            <list>
              <t>Argumentos: ninguno.
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: El comando obtiene como respuesta positiva el número de accesos que hubieron al servidor
                 desde que se inicializo. En el cazo de que el servidor no pueda responder satisfactoriamente al request
                este responderá con un estado de error apropiado.
              </t>
            </list>
          </t>
          <t>0x05, Transformación activa:
            <list>
              <t>Argumentos: ninguno.
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: El comando obtiene como respuesta la representación ASCII del programa de transformación
                que esta ejecutando el servidor. En el caso de no tener ningún programa de transformación se recibe
                una respuesta positiva sin ningún dato. Si por alguna razón no se pudo devolver la transformación
                activa entonces se devuelve un código de error apropiado como se especifico anterior mente
              </t>
            </list>
          </t>
          <t>0x06, Modificar el tamaño de los buffers:
            <list>
              <t>Argumentos: uno, la representación ASCII en decimal del nuevo tamaño para los buffers.
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: El comando cambia el tamaño que se le asignan a los buffers al momento de inciializar
                una nueva conexion al servidor. Si se pudo realizar el cambio con éxito entonces se obtiene como
                respuesta 0x00 (OK). En caso contrario se obtiene una respuesta con el error apropiado como se
                especifico anteriormente.
              </t>
            </list>
          </t>
          <t>0x07, Cambio de transformación:
            <list>
              <t>Argumentos: uno, la representación ASCII del nuevo comando de transformación.
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: El comando cambia la transformación a realizar. En el caso de querer desactivar
                las transformaciones simplemente se envía el comando de cambio de transformación sin datos.
                El servidor responde de manera positiva (0x00) cuando pudo cambiar con éxito las
                transformaciones, caso contrario responde con un error apropiado.
              </t>
            </list>
          </t>
          <t>0x09, Terminación de la sesión:
            <list>
              <t>Argumentos: ninguno
              </t>
              <t>Restricciones: Solo puede ser utilizado en el estado de transacción.
              </t>
              <t>Discusión: Cuando se envia un request con este comando se le avisa al servidor que el cliente
                 desea finalizar la sesión, el servidor responde de manera exitosa y termina la conexión.
              </t>
            </list>
          </t>
        </section>
        <section title="Limitaciones del protocolo">
          <t>El protocolo, dada su simpleza, posee varias limitaciones y las discutimos a continuación
          </t>
          <section title="Tamaño de los argumentos">
            <t>El protocolo posee un byte para indicar el tamaño del argumento, por lo que permite solamente
               argumentos de como maximo 255 bytes, esto no limita de manera sustancial el cambio del tamaño
               de los buffers ya que resultaría excesivo un buffer con un tamaño superior a 10^255 bytes.
               en cambio limita considerablemente la posibilidad de las transformaciones a realizar ya que
               la transformación debe ser un comando con una longitud máxima de 255 caracteres.
            </t>
          </section>
        </section>
      </section>
      <section title="Servidor SPCP">
        <section title="Introducción al servidor SPCP">
          <t>El proxy cuenta con un servidor SPCP implementado dentro del mismo proxy. Este servidor
            Implementa el lado servidor del protocolo SPCP para poder brindar monitoreo y metricas a los
            usuarios administradores del proxy
          </t>
        </section>
        <section title="Implementacion del servidor">
          <t>El servidor SPCP se implementa de manera no bloqueante y concurrente para poder permitir la
            ágil utilización del mismo por parte de multiples administradores. Para esto se utiliza una
            estructura de servidor similar a la que se presenta en el <eref target="1">servidor
            SocksV5</eref>. Se utiliza la estrategia de un selector el cual atiende a los file descriptors
            de los sockets mediante la funcion pselect.
          </t>
          <t>El servidor cuenta con un socket pasivo SCTP el cual escucha por defecto en el puerto 9090 pero
             puede ser alterado mediante los argumentos pasados al proxy en el momento de la inicialización.
             Este socket pasivo establece las conexiones entre el servidor SPCP y el cliente. Una vez
             establecida la conexión se procede al manejo de los requests y las responses.
          </t>
          <t>Se le da especial consideración al manejo de la autenticación dentro del servidor SPCP, ya que
            si bien el protocolo establece el mecanismo de autenticación, es el servidor quien decide como
            implementarlo. Para esto el servidor mantiene los nombres y contraseñas de los usuarios que tienen
            autoridad de administrar y en base a estos datos autentica al usuario y procede a atender los
            requests del mismo.
          </t>
        </section>
      </section>
      <section title="Cliente SPCP">
        <t>El trabajo practico cuenta con un cliente para poder demostrar las funcionalidades del servidor
           SPCP, este es relativamente simple pero permite al usuario utilizar toda la potencia del protocolo.
           El cliente permite especificar la IP y el puerto del servidor SPCP al cual desea conectarse.
        </t>
        <t>Al inciar el cliente este intenta conectarse con el servidor. De ser exitoso entonces procede a
           pedirle al usuario que se autentique mediante un usuario y contraseña validos. una vez autenticado
           se le presentan todas las opciones que puede elegir para interactuar con el servidor spcp. Puede
           realizar cuantas operaciones desee y terminar su sesión mediante el comando quit.</t>
      </section>
      <section title="Proxy POP3">
        <section title="introducción">
          <t>Al centro del trabajo practico se encuentra el proxy pop3. Se encarga de interactuar con el
             servidor origen y el cliente. El proxy le permite al cleinte poder acceder a su casilla de
             correo POP3 del servidor origen y beneficiarse del proxy. El cliente cuenta con soporte de
             pipelining independientemente de la implementación del servidor origen y ademas todos sus
             mensajes pasan por el proceso de transformación del proxy si este se encuentra activado.</t>
        </section>
        <section title="Resolución de nombres">
          <t>El proxy cuenta con la capacidad de hacer resolucion de nombres sin blockearse, asi un usuario
             del proxy no necesita conocer la ip de su servidor de origen sino que con su domain name basta.
          </t>
          <t>La resolución de nombres por su naturaleza es bloqueante, ya que debe realizar una consulta de
             DNS, es por esto que TODO
          </t>
        </section>
        <section title="Determinación de pipelining">
          <t>Como el proxy implementa pipelining independientemente de si el servidor origen lo implementa
             o no este debe poder detectar el
          </t>
        </section>
        <section title="Implementacion de piplining con servidor no pipeliner">

        </section>
        <section title="Manejo del request response">

        </section>
        <section title="Manejo de las transformaciones">

        </section>
      </section>
      <section title="censurador de mime types">

      </section>
    </section>
    <section title="Problemas encontrados">
      <section title="Determinación de pipelining">

      </section>
      <section title="Piplinging con servidor de origen no pipeliner">

      </section>
      <section title="Detección y transformación de mensajes">

      </section>
      <section title="Append capa">

      </section>
      <section title="casarnos al read">

      </section>
      <section title="escapado y desescapado al transform">

      </section>
      <section title="Resolución de nombres no bloqueante">

      </section>
    </section>
    <section title="Limitaciones">
      <section title="modificación del tamaño de los buffers">
        <t>se modifican los de las nuevas conexiones a partir del cambio, no dinamicamente las conexiones
           ya existentes</t>
      </section>
      <section title="modificación de content-transfer-encoding">
        <t>Si se debe reemplazar el content type y el header content-transfer-encoding se encuentra antes
          del header content-type entonces no se reemplaza por text/plain y el mensaje de reemplazo queda
          ilegible.
        </t>
      </section>
      <section title="Credenciales de los usuarios en el codigo">
        <t>En esta versión del proxy este implementa los nombres de usuarios directamente sobre el codigo
           Esto resulta inflexible al momento de agregar, modificar o quitar usuarios administradores ya
           que para esto se necesita bajar el servidor, cambiar el codigo fuente, recompilarlo y volverlo
          a subir</t>
      </section>
      <section title="Pipelining inutilizado">
        <t>Segun el RFC TODO(agregar ref) </t>
      </section>
    </section>
    <section title="Posibles extensiones">
      <section title="Agregado de timeouts">
        <t>Resultaría útil terminar una conexión que permaneció inactiva por mas de una determinada cantidad
           de tiempo, así se podría mejorar la performance del proxy ya que se irian purgando las conexiones
           inactivas
        </t>
        <section title="Repositorio de usuarios SPCP">
          <t>Para poder remover las credenciales de los usuarios administradores del codigo debemos poder
             guardarlas de alguna otra manera. Una posible implementación mas elegante es bajar los usuarios
             a un archivo de donde se levanten en tiempo de ejecución, esto permite que la modificación de los
             usuarios administradores sea tan simple como modificar un archivo y no se tenga que recompilar el
             binario
          </t>
        </section>
      </section>
    </section>
    <section title="conclusiones">
      
    </section>
    <section title="ejemplos de pruba">
      
    </section>
    <section title="Guía de instalación">
      
    </section>
    <section title="Instrucciones para la configuración">
      
    </section>
    <section title="Ejemplos de configuración y monitoreo">

    </section>
  </middle>
  <back>
    <references>
      <reference target="1">
        <front>
          <title>Server Socks V5</title>
          <author fullname="Juan F. Codagnone" initials="J.F.C">
            <organization>Juan F. Codagnone</organization>
            <address>
              <email>juan@leak.com.ar</email>
            </address>
          </author>
          <date month="3" year="2018"/>
        </front>
      </reference>
    </references>
  </back>
</rfc>

