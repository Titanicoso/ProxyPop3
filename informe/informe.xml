<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<rfc>
  <front>
    <title>
      Informe TPE Protocolos de comunicación
    </title>
    <author initials="F.D." surname="Delgado" fullname="Francisco Delgado">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <author initials="R.M.N.L" surname="Navarro Lajous" fullname="Rodrigo Manuel Navarro Lajous">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <author initials="S.F" surname="Favarón" fullname="Sebastián Favaron">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <author initials="A.C." surname="Calatayud" fullname="Agustín Calatayud">
      <organization>
        Instituto Tecnológico de Buenos Aires
      </organization>
    </author>
    <date month="11" year="2018"/>
    <area>Protocolos de Comunicación</area>
    <workgroup>Grupo 7</workgroup>
    <abstract>
      <t>This memo blah blah blah....
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro" title="Introducción">
      <t>

        <!--<list style="numbers">-->
          <!--<t>The first item.</t>-->
          <!--<t>The second item, which contains two bulleted sub-items:-->
            <!--<list style="symbols">-->
              <!--<t>The first sub-item.</t>-->
              <!--<t>The second sub-item.</t>-->
            <!--</list>-->
          <!--</t>-->
        <!--</list>-->
      </t>
    </section>
    <section title="El protocolo SPCP">
      <section title="introducción al protocolo">
        <t>El Simple Proxy Communication Protocol(SPCP) es un protocolo binario utilizado para poder
          configurar y obtener métricas de un servidor proxy. En el diseño del protocolo se priorizo
          la simpleza asi permitiendo que sea implementado lo mas fácilmente posible siempre y cuando
          no comprometa el objetivo principal de administrar el proxy
        </t>
      </section>
      <section title="Operación Básica">
        <t>Inicialmente, el servidor spcp inicializa su servicio escuchando en el puerto 9090 por default
          para aceptar conexiones sctp entrantes. Cuando el cliente desea utilizar el servicio este debe
          establecer una conexión sctp con el servidor.
        </t>
        <t>Una vez establecida la conexión se procede a la etapa de autenticación, el cliente manda su
          usuario y su contraseña y estos son validados por el servidor. Una vez autenticado se procede al
          estado de transacción en donde se mandan requests tanto para modificar el estado del proxy como
          para obtener métricas del mismo recibiendo para cada uno una respuesta con la informacion en el
          caso de que se haya podido obtener, o un estado de error apropiado. Finalmente se envía un request
          de terminación en donde se le indica al servidor que el cliente desea finalizar su sesión y el
          servidor da por finalizada la sesión.
        </t>
      </section>
      <section title="El request">
        <figure>
          <preamble>La estructura de un request</preamble>
          <artwork>
+-----+-------+----------+----------+...+----------+----------+
| CMD | NARGS | ARGLEN 1 |  ARG 1   |   | ARGLEN N |   ARG N  |
+-----+-------+----------+----------+...+----------+----------+
|  1  |   1   |    1     | Variable |   |    1     | Variable |
+-----+-------+----------+----------+...+----------+----------+
          </artwork>
        </figure>
        <t>El request se compone por un numero variable de segmentos, estos son:
          <list>
            <t>CMD: El identificador de comando, tiene un tamaño de un byte.
            </t>
            <t>NARGS: La cantidad de argumentos, tiene tamaño de un byte.
            </t>
            <t>ARGLEN: Cada argumento se encuentra precedido por el largo del mismo, este tiene un maximo
               de 255 ya que este campo tiene un byte de longitud.
            </t>
            <t>ARG: El argumento de tamaño anteriormente especificado, los argumentos son representaciones
              ASCII.
            </t>
          </list>
        </t>
      </section>
      <section title="La Response">
        <figure>
          <preamble>La estructura de un response</preamble>
          <artwork>
            +-------------+---------+----------+
            | STATUS_CODE | DATALEN |   DATA   |
            +-------------+---------+----------+
            |      1      |    1    | Variable |
            +-------------+---------+----------+
          </artwork>
        </figure>
        <t>El response se compone por un numero variable de segmentos, estos son:
          <list>
            <t>STATUS_CODE: Identifica el codigo de la respuesta.
            </t>
            <t>DATALEN: La longitud de los datos de la respuesta del servidor.
            </t>
            <t>DATA: Los datos enviados por el servidor, estos se encuentran en codificación ASCII.
            </t>
          </list>
        </t>
        <section title="Codigos de respuesta">
          <t>Discutimos brevemente los posibles codigos de respuesta que un servidor puede enviar a un cliente
          </t>
          <t>
            <list>
              <t>0x00: es el response de OK, indica que el request se ejecuto con exito por parte del servidor.
              </t>
              <t>0x01: Error de autenticación, indica que hubo un error al tratar de autenticar el usuario.
              </t>
              <t>0x02: Comando invalido, el comando que se envio en el request no es un comando valido.
              </t>
              <t>0x03: Argumentos invalidoos, indica que los argumentos para el comando no son validos.
              </t>
              <t>0x04: Error general, es el error de fallback del servidor cuando no puede especificar
                por que fallo.
              </t>
            </list>
          </t>
        </section>
      </section>
      <section title="Estado de autenticación">
        <t>Una vez inicializada la conexión el servidor se encuentra en el estado de autenticación. El cliente
        debe proveer su usuario mediante el comando 0x00, al cual llamaremos USER.
        </t>
        <t>El comando USER se compone de la siguiente manera:
          <list>
            <t>Argumentos: uno, la representación ASCII del nombre de usuario.
            </t>
            <t>Restricciones: Solo se puede utilizar en el estado de autenticación una vez inicializada la conexión
               o inmediatamente despues de un USER o PASS erróneo.
            </t>
            <t>Discusión: Primero se debe mandar el comando USER, si el usuario esta registrado entonces el servidor
              responde con una respuesta positiva mandando el byte 0x00.
            </t>
          </list>
        </t>
        <t>Inmediatamente despues del comando USER debe proveer mediante otro request la contraseña asociada al
          usuario. Para esto emite un request al servidor con el comando 0x01, al cual le llamaremos PASS de
          ahora en adelante.
        </t>
        <t>El comando PASS se compone de la siguiente manera:
          <list>
            <t>Argumentos: uno, la representación ASCII de la contraseña.
            </t>
            <t>Restricciones: Solo se puede utilizar en el estado de autenticación una vez inicializada la conexión
              e inmediatamente despues de un USER.
            </t>
          </list>
        </t>
      </section>
      <section title="Estado de transacción">

      </section>
    </section>
  </middle>
  <back>
    <references>
      <reference anchor="TODO">
        <front>
          <title>Server Socks V5</title>
          <author fullname="Juan F. Codagnone" initials="J.F.C">
            <organization>Juan F. Codagnone</organization>
            <address>
              <email>juan@leak.com.ar</email>
            </address>
          </author>
          <date month="3" year="2018"/>
        </front>
      </reference>
    </references>
  </back>
</rfc>

